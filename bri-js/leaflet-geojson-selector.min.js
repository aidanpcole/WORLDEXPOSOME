/* 
 * Leaflet GeoJSON Selector v0.5.4 - 2018-09-28 
 * 
 * Copyright 2018 Stefano Cudini 
 * stefano.cudini@gmail.com 
 * https://opengeo.tech/ 
 * 
 * Licensed under the MIT license. 
 * 
 * Demo: 
 * https://opengeo.tech/maps/leaflet-geojson-selector/ 
 * 
 * Source: 
 * git@github.com:stefanocudini/leaflet-geojson-selector.git 
 * 
 */
!function(a){if("function"==typeof define&&define.amd)define(["leaflet"],a);else if("undefined"!=typeof module)module.exports=a(require("leaflet"));else{if("undefined"==typeof window.L)throw"Leaflet must be loaded first";a(window.L)}}(function(a){return a.Control.GeoJSONSelector = a.Control.extend({
    includes: "1" === a.version[0] ? a.Evented.prototype : a.Mixin.Events,
    options: {
        position: "bottomleft",
        listLabel: "properties.name",
        listSortBy: null,
        listItemBuild: null,
        activeListFromLayer: !0,
        activeLayerFromList: !0,
        zoomToLayer: !1,
        listOnlyVisibleLayers: !1,
        multiple: !1,
        style: {
            color: "grey", // Default color for GeoJSON outlines
            fillColor: "#fff9db", // Background color for GeoJSON feature (if any)
            fillOpacity: 0.5, // Make the default fill fully transparent
            colorOpacity: 1, // Full opacity for borders
            weight: 1 // Default thickness for borders
        },
        activeClass: "active",
        activeStyle: {
            color: "black",
            fillColor: "#fff9db", // Background color when active (mouse-over)
            fillOpacity: 0, // Slight opacity when hovered or active
            colorOpacity: 1, // Full opacity for borders when active
            weight: 2 // Style applied on mouseover or active
        },
        selectClass: "selected",
        selectStyle: {
            color: "black", // Black outline for selected features
            fillColor: "#fff9db", // Background color when selected
            fillOpacity: 0, // Slight opacity when selected
            colorOpacity: 1, // Full opacity for selected features' borders
            weight: 2 // Thicker borders for selected features
        }
    },initialize:function(b,c){a.Util.setOptions(this,c||{});this.options.listSortBy=this.options.listSortBy||this.options.listLabel,this.options.listItemBuild&&(this._itemBuild=this.options.listItemBuild),this._layer=b},onAdd:function(b){var c=this;this._container=a.DomUtil.create("div","geojson-list"),this._baseName="geojson-list",this._map=b,this._id=this._baseName+a.stamp(this._container),this._list=a.DomUtil.create("ul","geojson-list-group",this._container),this._layer&&this._map.addLayer(this._layer),this._items=[],a.DomEvent.disableClickPropagation(this._container).disableScrollPropagation(this._container),this.options.listOnlyVisibleLayers&&b.on("moveend",this._updateVisible,this);var d=b.getSize();return c._container.style.height=d.y+"px",c._container.style.maxWidth=d.x/2+"px",c._update(),this._container},onRemove:function(a){a.off("moveend",this._updateVisible,this),this._layer.remove()},reload: function(newLayer) {
    // Store the currently selected feature
    const selectedFeature = this._items.find(item => item.selected);

    if (this._map) {
        if (this._layer) {
            this._map.removeLayer(this._layer);
        }
        this._map.addLayer(newLayer);
        this._layer = newLayer;
        this._update();
        
        // Reapply the selection highlight if a feature was selected before
        if (selectedFeature) {
            selectedFeature.layer.setStyle(this.options.selectStyle);
        }
    }
    return this;
},_getPath:function(a,b){var c=b.split("."),d=c.pop(),e=c.length,f=c[0],g=1;if(e>0)for(;(a=a[f])&&e>g;)f=c[g++];return a?a[d]:void 0},_itemBuild:function(a){return this._getPath(a.feature,this.options.listLabel)||"&nbsp;"},_selectItem: function(item, isSelected) {
    // Clear previous selections and make selected items non-clickable and non-hoverable
    this._items.forEach(i => {
        delete i.selected;
        L.DomUtil.removeClass(i, this.options.selectClass);

        // Re-enable the checkbox and hover for non-selected items
        const input = i.querySelector('input');
        if (input) input.disabled = false;
        i.layer.off('mouseover').off('mouseout'); // Re-enable hover effects
    });

    if (isSelected) {
        item.selected = isSelected;
        L.DomUtil.addClass(item, this.options.selectClass);

        // Disable the checkbox and hover for the selected item
        const selectedInput = item.querySelector('input');
        if (selectedInput) selectedInput.disabled = true;

        // Remove hover effects for the selected country
        item.layer.off('mouseover').off('mouseout');
    }
},_selectLayer:function(a,b){for(var c=0;c<this._items.length;c++)this._items[c].layer.setStyle&&this._items[c].layer.setStyle(this.options.style);b&&a.setStyle&&a.setStyle(this.options.selectStyle)},_createItem: function(layerItem) {
    var c = this,
        itemElement = a.DomUtil.create("li", "geojson-list-item"),
        label = document.createElement("label"),
        inputType = this.options.multiple ? "checkbox" : "radio",
        inputElement = this._createInputElement(inputType, this._id, false),
        labelText = this._itemBuild.call(this, layerItem);

    label.innerHTML = labelText;
    label.insertBefore(inputElement, label.firstChild);
    itemElement.appendChild(label);
    itemElement.layer = layerItem;
    layerItem.itemList = itemElement;
    layerItem.itemLabel = label;

    // Click event to select and disable the item once selected
    a.DomEvent.on(label, "click", a.DomEvent.stop, this)
        .on(label, "click", function(event) {
            // Disable further clicks if item is already selected
            if (itemElement.selected) return;

            inputElement.checked = !inputElement.checked;
            this._selectItem(itemElement, inputElement.checked);
            this._selectLayer(layerItem, inputElement.checked);
            this.fire("selector:change", { selected: inputElement.checked, layers: [layerItem] });
            if (this.options.zoomToLayer && inputElement.checked) this._moveTo(layerItem);
        }, this);

    // Hover effects for non-selected items only
    a.DomEvent.on(itemElement, "mouseover", function(event) {
        if (!itemElement.selected) {
            a.DomUtil.addClass(event.target, this.options.activeClass);
            layerItem.setStyle && layerItem.setStyle(this.options.activeStyle);
            if (c.options.activeLayerFromList) itemElement.layer.fire("mouseover");
        }
    }, this).on(itemElement, "mouseout", function(event) {
        if (!itemElement.selected) {
            a.DomUtil.removeClass(event.target, this.options.activeClass);
            layerItem.setStyle && layerItem.setStyle(this.options.style);
            if (c.options.activeLayerFromList) itemElement.layer.fire("mouseout");
        }
    }, this);

    this._items.push(itemElement);
    return itemElement;
},_createInputElement:function(a,b,c){var d='<input type="'+a+'" name="'+b+'"';c&&(d+=' checked="checked"'),d+="/>";var e=document.createElement("div");return e.innerHTML=d,e.firstChild},_update:function(){var b=this,c=[];if(this._layer){this._list.innerHTML="",this._layer.eachLayer(function(d){c.push(d),d.setStyle&&d.setStyle(b.options.style),d.on("click",a.DomEvent.stop).on("click",function(a){a.target.itemLabel.click()}).on("mouseover",function(c){c.target.setStyle&&c.target.setStyle(b.options.activeStyle),b.options.activeListFromLayer&&a.DomUtil.addClass(c.target.itemList,b.options.activeClass)}).on("mouseout",function(c){c.target.setStyle&&c.target.setStyle(c.target.itemList.selected?b.options.selectStyle:b.options.style),b.options.activeListFromLayer&&a.DomUtil.removeClass(c.target.itemList,b.options.activeClass)})}),this.options.listSortBy&&c.sort(function(a,c){var d=b.options.listSortBy,e=b._getPath(a.feature,d),f=b._getPath(c.feature,d);return f>e?-1:e>f?1:0});for(var d=0;d<c.length;d++)b._list.appendChild(b._createItem(c[d]));this._map.addLayer(this._layer),this._layer.getBounds&&setTimeout(function(){b._moveTo(38,23)})}},_updateVisible:function(){var a,b=this,c=b._map.getBounds();this._layer&&this._layer.eachLayer(function(b){b.getBounds?a=c.intersects(b.getBounds()):b.getLatLng&&(a=c.contains(b.getLatLng())),b.itemList&&(b.itemList.style.display=a?"block":"none")})},_moveTo: function(layer) {
    if (layer.feature) {
        const countryName = layer.feature.properties.name;
        
        // Define custom center and zoom level for each country if necessary
        const countryCenters = {
            "United States": { center: [47.69335, -122.5114], zoom: 4 },
            "India": { center: [20.5937, 78.9629], zoom: 5 },
            "Ireland": { center: [53.1424, -7.6921], zoom: 6 },
            "United Kingdom": { center: [55.3781, -3.4360], zoom: 6 },
            "Isle of Man": { center: [54.2361, -4.5481], zoom: 7 },
            // Add other countries here as needed
        };

        // Check if the country has a custom center and zoom level defined
        if (countryCenters[countryName]) {
            const { center, zoom } = countryCenters[countryName];
            this._map.flyTo(center, zoom, { animate: true, duration: 1.5 });
        } else if (layer.getBounds) {
            // Default handling for countries without a specified center and zoom
            const bounds = layer.getBounds();
            const center = bounds.getCenter();
            const zoom = this._map.getBoundsZoom(bounds);
            this._map.flyTo(center, zoom, { animate: true, duration: 1.5 });
        }
    }
}
}),a.control.geoJsonSelector=function(b,c){return new a.Control.GeoJSONSelector(b,c)},a.Control.GeoJSONSelector});