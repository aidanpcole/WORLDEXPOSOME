/* 
 * Leaflet GeoJSON Selector v0.5.4 - 2018-09-28 
 * 
 * Copyright 2018 Stefano Cudini 
 * stefano.cudini@gmail.com 
 * https://opengeo.tech/ 
 * 
 * Licensed under the MIT license. 
 * 
 * Demo: 
 * https://opengeo.tech/maps/leaflet-geojson-selector/ 
 * 
 * Source: 
 * git@github.com:stefanocudini/leaflet-geojson-selector.git 
 * 
 */
!function(a){if("function"==typeof define&&define.amd)define(["leaflet"],a);else if("undefined"!=typeof module)module.exports=a(require("leaflet"));else{if("undefined"==typeof window.L)throw"Leaflet must be loaded first";a(window.L)}}(function(a){return a.Control.GeoJSONSelector = a.Control.extend({
    includes: "1" === a.version[0] ? a.Evented.prototype : a.Mixin.Events,
    options: {
        position: "bottomleft",
        listLabel: "properties.name",
        listSortBy: null,
        listItemBuild: null,
        activeListFromLayer: !0,
        activeLayerFromList: !0,
        zoomToLayer: !1,
        listOnlyVisibleLayers: !1,
        multiple: !1,
        style: {
            color: "grey",
            fillColor: "#fff9db",
            fillOpacity: 0.5,
            colorOpacity: 1,
            weight: 1
        },
        activeClass: "active",
        activeStyle: {
            color: "black",
            fillColor: "#fff9db",
            fillOpacity: 0,
            colorOpacity: 1,
            weight: 2
        },
        selectClass: "selected",
        selectStyle: {
            color: "black",
            fillColor: "#fff9db",
            fillOpacity: 0,
            colorOpacity: 1,
            weight: 2
        }
    },
    initialize:function(b,c){
        a.Util.setOptions(this,c||{});
        this.options.listSortBy=this.options.listSortBy||this.options.listLabel;
        this.options.listItemBuild&&(this._itemBuild=this.options.listItemBuild);
        this._layer=b;
    },
    onAdd:function(b){
        var c=this;
        this._container=a.DomUtil.create("div","geojson-list");
        this._baseName="geojson-list";
        this._map=b;
        this._id=this._baseName+a.stamp(this._container);
        this._list=a.DomUtil.create("ul","geojson-list-group",this._container);
        this._layer&&this._map.addLayer(this._layer);
        this._items=[];
        a.DomEvent.disableClickPropagation(this._container).disableScrollPropagation(this._container);
        this.options.listOnlyVisibleLayers&&b.on("moveend",this._updateVisible,this);
        var d=b.getSize();
        c._container.style.height=d.y+"px";
        c._container.style.maxWidth=d.x/2+"px";
        c._update();
        return this._container;
    },
    onRemove:function(a){
        a.off("moveend",this._updateVisible,this);
        this._layer.remove();
    },
reload: function (newLayer) {
    // Preserve selected items before removing the current layer
    const selectedItems = this._items.filter(item => item.selected);
    const selectedFeatures = selectedItems.map(item => item.layer.feature.properties.name);

    if (this._map) {
        if (this._layer) {
            this._map.removeLayer(this._layer);
        }
        this._map.addLayer(newLayer);
        this._layer = newLayer;
        this._update();

        // Reapply selection state and styles to the new layer
        this._layer.eachLayer(layer => {
            if (selectedFeatures.includes(layer.feature.properties.name)) {
                layer.setStyle(this.options.selectStyle);
                layer.selected = true; // Mark as selected
                this._disableCurrentCountry(layer.itemList); // Disable interactions
            }
        });

        // Reapply bold styling for selected items in the list
        selectedItems.forEach(item => {
            L.DomUtil.addClass(item, this.options.selectClass);
            item.style.fontWeight = "bold"; // Reapply bold styling
        });
    }
    return this;
},
    _getPath:function(a,b){
        var c=b.split("."),d=c.pop(),e=c.length,f=c[0],g=1;
        if(e>0)for(;(a=a[f])&&e>g;)f=c[g++];
        return a?a[d]:void 0;
    },
    _itemBuild:function(a){
        return this._getPath(a.feature,this.options.listLabel)||"&nbsp;";
    },
_selectItem: function (item, isSelected) {
    this._items.forEach(i => {
        delete i.selected;
        L.DomUtil.removeClass(i, this.options.selectClass);

        const input = i.querySelector('input');
        if (input) input.disabled = false;
        i.style.pointerEvents = "auto"; // Re-enable interactivity
        i.style.fontWeight = ""; // Reset bold styling for non-selected items
    });

    if (isSelected) {
        item.selected = isSelected;
        L.DomUtil.addClass(item, this.options.selectClass);

        const selectedInput = item.querySelector('input');
        if (selectedInput) selectedInput.disabled = true;

        item.style.fontWeight = "bold"; // Ensure bold styling
        this._disableCurrentCountry(item); // Disable interactions
    }
},
    _selectLayer:function(a,b){
        for(var c=0;c<this._items.length;c++)this._items[c].layer.setStyle&&this._items[c].layer.setStyle(this.options.style);
        b&&a.setStyle&&a.setStyle(this.options.selectStyle);
    },
_createItem: function (layerItem) {
    var c = this,
        itemElement = a.DomUtil.create("li", "geojson-list-item"),
        label = document.createElement("label"),
        inputType = this.options.multiple ? "checkbox" : "radio",
        inputElement = this._createInputElement(inputType, this._id, false),
        labelText = this._itemBuild.call(this, layerItem);

    label.innerHTML = labelText;
    label.insertBefore(inputElement, label.firstChild);
    itemElement.appendChild(label);
    itemElement.layer = layerItem;
    layerItem.itemList = itemElement;
    layerItem.itemLabel = label;

    // Add click interaction to the list item
    a.DomEvent.on(label, "click", a.DomEvent.stop, this)
        .on(label, "click", function (event) {
            if (itemElement.selected) return; // Prevent re-selecting already selected country

            inputElement.checked = !inputElement.checked;
            this._selectItem(itemElement, inputElement.checked);
            this._selectLayer(layerItem, inputElement.checked);
            this.fire("selector:change", { selected: inputElement.checked, layers: [layerItem] });
            if (this.options.zoomToLayer && inputElement.checked) this._moveTo(layerItem);
        }, this);

    // Add hover interactions to the list item
    a.DomEvent.on(itemElement, "mouseover", function (event) {
        if (!itemElement.selected) {
            a.DomUtil.addClass(event.target, this.options.activeClass);
            layerItem.setStyle && layerItem.setStyle(this.options.activeStyle);
            if (c.options.activeLayerFromList) itemElement.layer.fire("mouseover");
        }
    }, this).on(itemElement, "mouseout", function (event) {
        if (!itemElement.selected) {
            a.DomUtil.removeClass(event.target, this.options.activeClass);
            layerItem.setStyle && layerItem.setStyle(this.options.style);
            if (c.options.activeLayerFromList) itemElement.layer.fire("mouseout");
        }
    }, this);

    this._items.push(itemElement);
    return itemElement;
},
_disableCurrentCountry: function (item) {
    const input = item.querySelector('input');
    if (input) input.disabled = true; // Disable input for selected country

    item.style.pointerEvents = "none"; // Prevent any interactions
    item.style.cursor = "default"; // Change cursor to default
}, 
    _createInputElement:function(a,b,c){
        var d='<input type="'+a+'" name="'+b+'"';
        c&&(d+=' checked="checked"');
        d+="/>";
        var e=document.createElement("div");
        return e.innerHTML=d,e.firstChild;
    },
_update: function () {
    const b = this,
        c = [];
    if (this._layer) {
        this._list.innerHTML = "";
        this._layer.eachLayer(function (d) {
            c.push(d);
            d.setStyle && d.setStyle(b.options.style);

            d.off("click").on("click", function (e) {
                d.itemLabel.click(); // Sync click with selector
            });

            d.on("mouseover", function (c) {
                c.target.setStyle && c.target.setStyle(b.options.activeStyle);
                b.options.activeListFromLayer && L.DomUtil.addClass(c.target.itemList, b.options.activeClass);
            });

            d.on("mouseout", function (c) {
                c.target.setStyle &&
                    c.target.setStyle(
                        c.target.itemList.selected ? b.options.selectStyle : b.options.style
                    );
                b.options.activeListFromLayer && L.DomUtil.removeClass(c.target.itemList, b.options.activeClass);
            });
        });

        // Rebuild the list and preserve selected item styles
        c.forEach(layer => {
            const item = b._createItem(layer);
            if (layer.selected) {
                L.DomUtil.addClass(item, this.options.selectClass);
                item.style.fontWeight = "bold"; // Reapply bold styling
            }
            b._list.appendChild(item);
        });

        this._map.addLayer(this._layer);
    }
},
    _updateVisible:function(){
        var a,b=this,c=b._map.getBounds();
        this._layer && this._layer.eachLayer(function(b){
            b.getBounds ? a=c.intersects(b.getBounds()) : b.getLatLng && (a=c.contains(b.getLatLng()));
            b.itemList && (b.itemList.style.display=a?"block":"none");
        });
    },
    _moveTo:function(layer){
        if (layer.feature) {
            const countryName = layer.feature.properties.name;
            
            const countryCenters = {
                "United States": { center: [47.69335, -122.5114], zoom: 4 },
                "India": { center: [20.5937, 78.9629], zoom: 5 },
                "Ireland": { center: [53.1424, -7.6921], zoom: 6 },
                "United Kingdom": { center: [55.3781, -3.4360], zoom: 6 },
                "Isle of Man": { center: [54.2361, -4.5481], zoom: 7 }
            };

            if (countryCenters[countryName]) {
                const { center, zoom } = countryCenters[countryName];
                this._map.flyTo(center, zoom, { animate: true, duration: 1.5 });
            } else if (layer.getBounds) {
                const bounds = layer.getBounds();
                const center = bounds.getCenter();
                const zoom = this._map.getBoundsZoom(bounds);
                this._map.flyTo(center, zoom, { animate: true, duration: 1.5 });
            }
        }
    }
}),a.control.geoJsonSelector=function(b,c){return new a.Control.GeoJSONSelector(b,c)},a.Control.GeoJSONSelector});



